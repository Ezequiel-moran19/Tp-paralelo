1Ô∏è‚É£ Evento principal en el Controller (ProductosController)
contenedor.addEventListener("click", (e) => {
    e.preventDefault();


Captura todos los clics dentro del contenedor de productos.

Se usa delegaci√≥n de eventos en lugar de agregar un listener a cada bot√≥n, porque:

Es m√°s eficiente (solo un listener para todo el contenedor).

Evita problemas cuando se renderizan productos nuevos.

Si se agregara addEventListener en cada card, ser√≠a m√°s costoso y dif√≠cil de mantener.

if (e.target && e.target.classList.contains("btnAgregar")) {


Verifica que el clic fue en el bot√≥n ‚ÄúAgregar al carrito‚Äù.

As√≠ evitamos ejecutar la l√≥gica en otros elementos dentro del contenedor.

üß© 2Ô∏è‚É£ Ocultar el bot√≥n y preparar el contador
const card = e.target.closest(".card");
const nombre = card.querySelector(".card-title").textContent.replace("Nombre: ", "");
e.target.style.display = "none";


closest(".card"): busca el contenedor .card m√°s cercano al bot√≥n, para manipular solo esa tarjeta.

replace("Nombre: ", ""): limpia el texto del t√≠tulo, dejando solo el nombre del producto.

style.display = "none": oculta el bot√≥n ‚ÄúAgregar‚Äù, porque el producto ya fue agregado.

No se elimina el bot√≥n, solo se oculta, para poder mostrarlo de nuevo si el producto se quita.

üß© 3Ô∏è‚É£ Crear los nuevos botones (+, ‚Äì) y contador
const btnSumar = ProductosView.crearBotonSumar();
const contador = ProductosView.renderContador();
const btnRestar = ProductosView.crearBotonRestar();


Se crean los tres elementos con funciones peque√±as y espec√≠ficas.

Esto mejora la modularidad: si quer√©s cambiar el dise√±o o estilo de los botones, lo hac√©s en una sola funci√≥n.

Adem√°s, mantiene el Controller limpio (solo maneja l√≥gica, no HTML).

üß© 4Ô∏è‚É£ Crear el contenedor de botones
const contenedorBtn = document.createElement("div");
contenedorBtn.classList.add("d-flex", "justify-content-center", "align-items-center", "mt-2");
contenedorBtn.append(btnRestar, contador, btnSumar);


Se genera un <div> para agrupar los botones y el contador.

Se usan clases Bootstrap para mantener el formato.

Se insertan los tres elementos en orden visual: ‚Äì [contador] +.

Se usa append en lugar de innerHTML para evitar sobrescribir contenido o listeners previos.

üß© 5Ô∏è‚É£ Insertar el grupo en la card
card.querySelector(".card-body").appendChild(contenedorBtn);


Se agrega el bloque al final del cuerpo de la tarjeta.

Se podr√≠a usar insertAdjacentElement, pero appendChild es m√°s simple y claro en este caso.

üß© 6Ô∏è‚É£ Buscar el producto en la lista y pasar a la vista
const producto = productos.find(p => p.nombre === nombre);
ProductosView.agregarEventosCard(card, producto);


Busca el objeto del producto real en el array productos, para conocer su stock, precio, etc.

Luego llama a agregarEventosCard (definida en la vista) para conectar los botones con su l√≥gica.

üß© 7Ô∏è‚É£ Dentro de ProductosView.agregarEventosCard
‚ûï Bot√≥n sumar
btnSumar.addEventListener("click", (e) => {
    e.preventDefault();
    let valor = parseInt(contador.textContent);
    if (valor < producto.stock) {
        contador.textContent = valor + 1;
    }
});


Aumenta el contador, pero solo si no supera el stock disponible.

Se podr√≠a guardar tambi√©n en localStorage aqu√≠, pero se recomienda hacerlo en el Controller (para mantener la separaci√≥n entre vista y l√≥gica).

‚ûñ Bot√≥n restar
btnRestar.addEventListener("click", (e) => {
    e.preventDefault();
    let valor = parseInt(contador.textContent);
    if (valor > 1) {
        contador.textContent = valor - 1;
    } else {
        const contenedorBtn = card.querySelector("div.mt-2");
        if (contenedorBtn) contenedorBtn.remove();
        card.querySelector(".btnAgregar").style.display = "block";
    }
});


Si el valor es mayor a 1 ‚Üí simplemente resta.

Si llega a 1 y vuelve a restar ‚Üí se interpreta como eliminaci√≥n del producto del carrito.

El bloque de botones se borra del DOM.

Se vuelve a mostrar el bot√≥n ‚ÄúAgregar al carrito‚Äù.

Se elige quitar el bloque del DOM y no solo ocultarlo para liberar espacio visual y evitar listeners activos innecesarios.

‚öôÔ∏è Por qu√© esta estructura y no otra

‚úÖ Separaci√≥n clara de responsabilidades

Controller: maneja la l√≥gica de eventos y flujo.

View: maneja el DOM y la presentaci√≥n.

‚úÖ Uso de delegaci√≥n de eventos

Solo un listener principal en lugar de uno por bot√≥n (mejor rendimiento y mantenimiento).

‚úÖ Reutilizaci√≥n de funciones peque√±as

Facilita pruebas y futuras modificaciones.

‚úÖ Evita duplicar listeners

Cada card solo tiene un conjunto de botones y listeners mientras exista.

‚úÖ Base lista para integrar con localStorage

Los cambios en cantidad o eliminaci√≥n pueden luego reflejarse en el almacenamiento sin alterar esta l√≥gica base.